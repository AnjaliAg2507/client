{"ast":null,"code":"import _orderBy from \"lodash/orderBy\";\nimport _keys from \"lodash/keys\";\nimport _assign from \"lodash/assign\";\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport React from \"react\";\nimport { Helpers, Scale, Wrapper } from \"victory-core\";\nimport isEqual from \"react-fast-compare\";\nvar fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50\n}; // Assumes data in `datasets` is sorted by `Data.getData`.\n\nfunction fillData(props, datasets) {\n  var fillInMissingData = props.fillInMissingData;\n  var xMap = datasets.reduce(function (prev, dataset) {\n    dataset.forEach(function (datum) {\n      prev[datum._x instanceof Date ? datum._x.getTime() : datum._x] = true;\n    });\n    return prev;\n  }, {});\n  var xKeys = _keys(xMap).map(function (k) {\n    return Number(k);\n  });\n  var xArr = _orderBy(xKeys);\n  return datasets.map(function (dataset) {\n    var indexOffset = 0;\n    var isDate = dataset[0] && dataset[0]._x instanceof Date;\n    var filledInData = xArr.map(function (x, index) {\n      x = Number(x);\n      var datum = dataset[index - indexOffset];\n      if (datum) {\n        var x1 = isDate ? datum._x.getTime() : datum._x;\n        if (x1 === x) {\n          return datum;\n        }\n        indexOffset++;\n        var _y = fillInMissingData ? 0 : null;\n        x = isDate ? new Date(x) : x;\n        return {\n          x: x,\n          y: _y,\n          _x: x,\n          _y: _y\n        };\n      }\n      var y = fillInMissingData ? 0 : null;\n      x = isDate ? new Date(x) : x;\n      return {\n        x: x,\n        y: y,\n        _x: x,\n        _y: y\n      };\n    });\n    return filledInData;\n  });\n}\nfunction getY0(datum, index, datasets) {\n  if (datum.y0) {\n    return datum.y0;\n  }\n  var y = datum._y;\n  var group = datum._group;\n  var firstDatasetBaseline = datasets[0].map(function (d) {\n    return d.y0;\n  });\n  var previousDatasets = datasets.slice(0, index);\n  var previousPoints = previousDatasets.reduce(function (prev, dataset) {\n    return prev.concat(dataset.filter(function (previousDatum) {\n      return datum._x instanceof Date ? previousDatum._x.getTime() === datum._x.getTime() : previousDatum._x === datum._x;\n    }).map(function (previousDatum) {\n      return previousDatum._y || 0;\n    }));\n  }, []);\n  var y0 = previousPoints.length && previousPoints.reduce(function (memo, value) {\n    var sameSign = y < 0 && value < 0 || y >= 0 && value >= 0;\n    return sameSign ? Number(value) + memo : memo;\n  }, firstDatasetBaseline[group] || 0);\n  return previousPoints.some(function (point) {\n    return point instanceof Date;\n  }) ? new Date(y0) : y0;\n}\n/* eslint-disable no-nested-ternary */\n\nfunction addLayoutData(props, datasets, index) {\n  var xOffset = props.xOffset || 0;\n  return datasets[index].map(function (datum) {\n    var yOffset = getY0(datum, index, datasets) || 0;\n    return _assign({}, datum, {\n      _y0: !(datum._y instanceof Date) ? yOffset : yOffset ? new Date(yOffset) : datum._y,\n      _y1: datum._y === null ? null : datum._y instanceof Date ? new Date(Number(datum._y) + Number(yOffset)) : datum._y + yOffset,\n      _x1: datum._x === null ? null : datum._x instanceof Date ? new Date(Number(datum._x) + Number(xOffset)) : datum._x + xOffset\n    });\n  });\n}\n/* eslint-enable no-nested-ternary */\n\nfunction stackData(props, childComponents) {\n  var dataFromChildren = Wrapper.getDataFromChildren(props, childComponents);\n  var filterNullChildData = dataFromChildren.map(function (dataset) {\n    return dataset.filter(function (datum) {\n      return datum._x !== null && datum._y !== null;\n    });\n  });\n  var datasets = fillData(props, filterNullChildData);\n  return datasets.map(function (d, i) {\n    return addLayoutData(props, datasets, i);\n  });\n}\nexport function getCalculatedProps(props, childComponents) {\n  childComponents = childComponents || React.Children.toArray(props.children);\n  var role = \"stack\";\n  props = Helpers.modifyProps(props, fallbackProps, role);\n  var style = Wrapper.getStyle(props.theme, props.style, role);\n  var categories = props.categories || Wrapper.getCategories(props, childComponents);\n  var datasets = props.datasets || stackData(props, childComponents);\n  var children = childComponents.map(function (c, i) {\n    return /*#__PURE__*/React.cloneElement(c, {\n      data: datasets[i]\n    });\n  });\n  var domain = {\n    x: Wrapper.getDomain(_assign({}, props, {\n      categories: categories\n    }), \"x\", children),\n    y: Wrapper.getDomain(_assign({}, props, {\n      categories: categories\n    }), \"y\", children)\n  };\n  var range = props.range || {\n    x: Helpers.getRange(props, \"x\"),\n    y: Helpers.getRange(props, \"y\")\n  };\n  var baseScale = {\n    x: Scale.getScaleFromProps(props, \"x\") || Wrapper.getScale(props, \"x\"),\n    y: Scale.getScaleFromProps(props, \"y\") || Wrapper.getScale(props, \"y\")\n  };\n  var scale = {\n    x: baseScale.x.domain(domain.x).range(props.horizontal ? range.y : range.x),\n    y: baseScale.y.domain(domain.y).range(props.horizontal ? range.x : range.y)\n  };\n  var _props = props,\n    colorScale = _props.colorScale,\n    horizontal = _props.horizontal;\n  return {\n    datasets: datasets,\n    categories: categories,\n    range: range,\n    domain: domain,\n    horizontal: horizontal,\n    scale: scale,\n    style: style,\n    colorScale: colorScale,\n    role: role\n  };\n} // We need to remove sharedEvents in order to memoize the calculated data\n// With shared events, the props change on every event, and every value is re-calculated\n\nvar withoutSharedEvents = function withoutSharedEvents(props) {\n  var children = props.children;\n  var modifiedChildren = React.Children.toArray(children).map(function (_child) {\n    var child = _child;\n    return _objectSpread(_objectSpread({}, child), {}, {\n      props: Helpers.omit(child.props, [\"sharedEvents\"])\n    });\n  });\n  props.children = modifiedChildren;\n  return props;\n};\nexport function useMemoizedProps(initialProps) {\n  var modifiedProps = withoutSharedEvents(initialProps);\n  var _React$useState = React.useState(modifiedProps),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    props = _React$useState2[0],\n    setProps = _React$useState2[1]; // React.memo uses shallow equality to compare objects. This way props\n  // will only be re-calculated when they change.\n\n  React.useEffect(function () {\n    if (!isEqual(modifiedProps, props)) {\n      setProps(modifiedProps);\n    }\n  }, [props, setProps, modifiedProps]);\n  return React.useMemo(function () {\n    return getCalculatedProps(props, props.children);\n  }, [props]);\n}\nfunction getLabels(props, datasets, index) {\n  if (!props.labels) {\n    return undefined;\n  }\n  return datasets.length === index + 1 ? props.labels : undefined;\n}\nexport function getChildProps(props, calculatedProps) {\n  var categories = calculatedProps.categories,\n    domain = calculatedProps.domain,\n    range = calculatedProps.range,\n    scale = calculatedProps.scale,\n    horizontal = calculatedProps.horizontal;\n  return {\n    height: props.height,\n    width: props.width,\n    padding: Helpers.getPadding(props),\n    standalone: false,\n    theme: props.theme,\n    categories: categories,\n    domain: domain,\n    range: range,\n    scale: scale,\n    horizontal: horizontal\n  };\n}\nfunction getColorScale(props, child) {\n  var role = child.type && child.type.role;\n  var colorScaleOptions = child.props.colorScale || props.colorScale;\n  if (role !== \"group\" && role !== \"stack\") {\n    return undefined;\n  }\n  return props.theme ? colorScaleOptions || props.theme.props.colorScale : colorScaleOptions;\n}\nexport function getChildren(props, childComponents, calculatedProps) {\n  props = Helpers.modifyProps(props, fallbackProps, \"stack\");\n  childComponents = childComponents || React.Children.toArray(props.children);\n  calculatedProps = calculatedProps || getCalculatedProps(props, childComponents);\n  var _calculatedProps = calculatedProps,\n    datasets = _calculatedProps.datasets;\n  var childProps = getChildProps(props, calculatedProps);\n  var parentName = props.name || \"stack\";\n  return childComponents.map(function (child, index) {\n    var role = child.type && child.type.role;\n    var data = datasets[index];\n    var style = Wrapper.getChildStyle(child, index, calculatedProps);\n    var labels = props.labels ? getLabels(props, datasets, index) : child.props.labels;\n    var name = child.props.name || \"\".concat(parentName, \"-\").concat(role, \"-\").concat(index);\n    return /*#__PURE__*/React.cloneElement(child, _assign({\n      key: \"\".concat(name, \"-key-\").concat(index),\n      labels: labels,\n      name: name,\n      domainPadding: child.props.domainPadding || props.domainPadding,\n      theme: props.theme,\n      labelComponent: props.labelComponent || child.props.labelComponent,\n      style: style,\n      colorScale: getColorScale(props, child),\n      data: data,\n      polar: props.polar\n    }, childProps));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
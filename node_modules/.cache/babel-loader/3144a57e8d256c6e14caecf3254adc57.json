{"ast":null,"code":"import _delay from \"lodash/delay\";\nimport _defaults from \"lodash/defaults\";\nimport _isFunction from \"lodash/isFunction\";\nimport _throttle from \"lodash/throttle\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 1, 2, 1000] }]*/\nimport { Children } from \"react\";\nimport { Selection, Collection, Wrapper } from \"victory-core\";\nvar RawZoomHelpers = {\n  checkDomainEquality: function checkDomainEquality(a, b) {\n    var checkDimension = function checkDimension(dim) {\n      var val1 = a && a[dim];\n      var val2 = b && b[dim];\n      if (!val1 && !val2) {\n        return true;\n      } else if (!val1 || !val2) {\n        return false;\n      }\n      return Number(val1[0]) === Number(val2[0]) && Number(val1[1]) === Number(val2[1]);\n    };\n    return checkDimension(\"x\") && checkDimension(\"y\");\n  },\n  /**\n   * Generates a new domain scaled by factor and constrained by the original domain.\n   * @param  {[Number, Number]} currentDomain  The domain to be scaled.\n   * @param  {Object} evt the event object\n   * @param  {Object} props the props of the targeted component\n   * @param  {String} axis the desired dimension (either x or y)\n   * @return {[Number, Number]}                The scale domain\n   */\n  // eslint-disable-next-line max-params\n  scale: function scale(currentDomain, evt, props, axis) {\n    var _currentDomain = _slicedToArray(currentDomain, 2),\n      from = _currentDomain[0],\n      to = _currentDomain[1];\n    var range = Math.abs(to - from);\n    var minimumZoom = props.minimumZoom && props.minimumZoom[axis];\n    var factor = this.getScaleFactor(evt);\n    if (minimumZoom && range <= minimumZoom && factor < 1) {\n      return currentDomain;\n    }\n    var _this$getDomain$axis = _slicedToArray(this.getDomain(props)[axis], 2),\n      fromBound = _this$getDomain$axis[0],\n      toBound = _this$getDomain$axis[1];\n    var percent = this.getScalePercent(evt, props, axis);\n    var point = factor * from + percent * (factor * range);\n    var minDomain = this.getMinimumDomain(point, props, axis);\n    var _this$getScaledDomain = this.getScaledDomain(currentDomain, factor, percent),\n      _this$getScaledDomain2 = _slicedToArray(_this$getScaledDomain, 2),\n      newMin = _this$getScaledDomain2[0],\n      newMax = _this$getScaledDomain2[1];\n    var newDomain = [newMin > fromBound && newMin < toBound ? newMin : fromBound, newMax < toBound && newMax > fromBound ? newMax : toBound];\n    var domain = Math.abs(minDomain[1] - minDomain[0]) > Math.abs(newDomain[1] - newDomain[0]) ? minDomain : newDomain;\n    return Collection.containsDates([fromBound, toBound]) ? [new Date(domain[0]), new Date(domain[1])] : domain;\n  },\n  getScaledDomain: function getScaledDomain(currentDomain, factor, percent) {\n    var _currentDomain2 = _slicedToArray(currentDomain, 2),\n      from = _currentDomain2[0],\n      to = _currentDomain2[1];\n    var range = Math.abs(to - from);\n    var diff = range - range * factor;\n    var newMin = Number(from) + diff * percent;\n    var newMax = Number(to) - diff * (1 - percent);\n    return [Math.min(newMin, newMax), Math.max(newMin, newMax)];\n  },\n  getMinimumDomain: function getMinimumDomain(point, props, axis) {\n    var minimumZoom = props.minimumZoom;\n    var originalDomain = this.getDomain(props)[axis];\n    var _originalDomain = _slicedToArray(originalDomain, 2),\n      from = _originalDomain[0],\n      to = _originalDomain[1];\n    var defaultMin = Math.abs(from - to) / 1000;\n    var extent = minimumZoom ? minimumZoom[axis] || defaultMin : defaultMin;\n    var minExtent = point - extent / 2;\n    var maxExtent = point + extent / 2;\n    return [minExtent > from && minExtent < to ? minExtent : from, maxExtent < to && maxExtent > from ? maxExtent : Number(from) + extent / 2];\n  },\n  zoommingOut: function zoommingOut(evt) {\n    return evt.deltaY > 0;\n  },\n  getScaleFactor: function getScaleFactor(evt) {\n    var sign = this.zoommingOut(evt) ? 1 : -1; // eslint-disable-next-line no-magic-numbers\n\n    var delta = Math.min(Math.abs(evt.deltaY / 300), 0.5); // TODO: Check scale factor\n\n    return Math.abs(1 + sign * delta);\n  },\n  getScalePercent: function getScalePercent(evt, props, axis) {\n    var originalDomain = this.getDomain(props);\n    var _originalDomain$axis = _slicedToArray(originalDomain[axis], 2),\n      from = _originalDomain$axis[0],\n      to = _originalDomain$axis[1];\n    var position = this.getPosition(evt, props, originalDomain);\n    return (position[axis] - from) / Math.abs(to - from);\n  },\n  getPosition: function getPosition(evt, props, originalDomain) {\n    var _Selection$getSVGEven = Selection.getSVGEventCoordinates(evt),\n      x = _Selection$getSVGEven.x,\n      y = _Selection$getSVGEven.y;\n    var originalScale = {\n      x: props.scale.x.domain(originalDomain.x),\n      y: props.scale.y.domain(originalDomain.y)\n    };\n    return Selection.getDataCoordinates(props, originalScale, x, y);\n  },\n  /**\n   * Generate a new domain translated by the delta and constrained by the original domain.\n   * @param  {[Number, Number]} currentDomain  The domain to be translated.\n   * @param  {[Number, Number]} originalDomain The original domain for the data set.\n   * @param  {Number}           delta          The delta to translate by\n   * @return {[Number, Number]}                The translated domain\n   */\n  pan: function pan(currentDomain, originalDomain, delta) {\n    var _currentDomain$map = currentDomain.map(function (val) {\n        return Number(val);\n      }),\n      _currentDomain$map2 = _slicedToArray(_currentDomain$map, 2),\n      fromCurrent = _currentDomain$map2[0],\n      toCurrent = _currentDomain$map2[1];\n    var _originalDomain$map = originalDomain.map(function (val) {\n        return Number(val);\n      }),\n      _originalDomain$map2 = _slicedToArray(_originalDomain$map, 2),\n      fromOriginal = _originalDomain$map2[0],\n      toOriginal = _originalDomain$map2[1];\n    var lowerBound = fromCurrent + delta;\n    var upperBound = toCurrent + delta;\n    var newDomain;\n    if (lowerBound > fromOriginal && upperBound < toOriginal) {\n      newDomain = [lowerBound, upperBound];\n    } else if (lowerBound < fromOriginal) {\n      // Clamp to lower limit\n      var dx = toCurrent - fromCurrent;\n      newDomain = [fromOriginal, fromOriginal + dx];\n    } else if (upperBound > toOriginal) {\n      // Clamp to upper limit\n      var _dx = toCurrent - fromCurrent;\n      newDomain = [toOriginal - _dx, toOriginal];\n    } else {\n      newDomain = currentDomain;\n    }\n    return Collection.containsDates(currentDomain) || Collection.containsDates(originalDomain) ? newDomain.map(function (val) {\n      return new Date(val);\n    }) : newDomain;\n  },\n  getDomainScale: function getDomainScale(domain, scale, axis) {\n    var axisDomain = Array.isArray(domain) ? domain : domain[axis];\n    var _axisDomain = _slicedToArray(axisDomain, 2),\n      from = _axisDomain[0],\n      to = _axisDomain[1];\n    var range = scale[axis].range();\n    var plottableWidth = Math.abs(range[0] - range[1]);\n    return plottableWidth / (to - from);\n  },\n  handleAnimation: function handleAnimation(ctx) {\n    var animationTimer = ctx.context.animationTimer;\n    var transitionTimer = ctx.context.transitionTimer;\n    transitionTimer.bypassAnimation();\n    animationTimer.bypassAnimation();\n    var resumeAnimation = function resumeAnimation() {\n      animationTimer.resumeAnimation();\n      transitionTimer.resumeAnimation();\n    }; // delay the callback that resumes animation by ~1 frame so that animation does not interfere with wheel events\n\n    return _delay(resumeAnimation, 16); // eslint-disable-line no-magic-numbers\n  },\n\n  getLastDomain: function getLastDomain(targetProps, originalDomain) {\n    var zoomDomain = targetProps.zoomDomain,\n      cachedZoomDomain = targetProps.cachedZoomDomain,\n      currentDomain = targetProps.currentDomain,\n      domain = targetProps.domain;\n    if (zoomDomain && !this.checkDomainEquality(zoomDomain, cachedZoomDomain)) {\n      return _defaults({}, zoomDomain, domain);\n    }\n    return _defaults({}, currentDomain || zoomDomain || originalDomain, domain);\n  },\n  getDomain: function getDomain(props) {\n    var originalDomain = props.originalDomain,\n      domain = props.domain,\n      children = props.children,\n      zoomDimension = props.zoomDimension;\n    var childComponents = Children.toArray(children);\n    var childrenDomain = {};\n    if (childComponents.length) {\n      childrenDomain = zoomDimension ? _defineProperty({}, zoomDimension, Wrapper.getDomainFromChildren(props, zoomDimension, childComponents)) : {\n        x: Wrapper.getDomainFromChildren(props, \"x\", childComponents),\n        y: Wrapper.getDomainFromChildren(props, \"y\", childComponents)\n      };\n    }\n    return _defaults({}, childrenDomain, originalDomain, domain);\n  },\n  onMouseDown: function onMouseDown(evt, targetProps) {\n    evt.preventDefault();\n    if (!targetProps.allowPan) {\n      return undefined;\n    }\n    var parentSVG = targetProps.parentSVG || Selection.getParentSVG(evt);\n    var _Selection$getSVGEven2 = Selection.getSVGEventCoordinates(evt, parentSVG),\n      x = _Selection$getSVGEven2.x,\n      y = _Selection$getSVGEven2.y;\n    return [{\n      target: \"parent\",\n      mutation: function mutation() {\n        return {\n          startX: x,\n          startY: y,\n          panning: true,\n          parentSVG: parentSVG,\n          parentControlledProps: [\"domain\"]\n        };\n      }\n    }];\n  },\n  onMouseUp: function onMouseUp(evt, targetProps) {\n    if (!targetProps.allowPan) {\n      return undefined;\n    }\n    return [{\n      target: \"parent\",\n      mutation: function mutation() {\n        return {\n          panning: false\n        };\n      }\n    }];\n  },\n  onMouseLeave: function onMouseLeave(evt, targetProps) {\n    if (!targetProps.allowPan) {\n      return undefined;\n    }\n    return [{\n      target: \"parent\",\n      mutation: function mutation() {\n        return {\n          panning: false\n        };\n      }\n    }];\n  },\n  // eslint-disable-next-line max-params, max-statements\n  onMouseMove: function onMouseMove(evt, targetProps, eventKey, ctx) {\n    if (targetProps.panning && targetProps.allowPan) {\n      var scale = targetProps.scale,\n        startX = targetProps.startX,\n        startY = targetProps.startY,\n        onZoomDomainChange = targetProps.onZoomDomainChange,\n        zoomDomain = targetProps.zoomDomain,\n        zoomDimension = targetProps.zoomDimension,\n        horizontal = targetProps.horizontal;\n      var parentSVG = targetProps.parentSVG || Selection.getParentSVG(evt);\n      var _Selection$getSVGEven3 = Selection.getSVGEventCoordinates(evt, parentSVG),\n        x = _Selection$getSVGEven3.x,\n        y = _Selection$getSVGEven3.y;\n      var originalDomain = this.getDomain(targetProps);\n      var lastDomain = this.getLastDomain(targetProps, originalDomain);\n      var deltaX = horizontal ? y - startY : startX - x;\n      var deltaY = horizontal ? startX - x : y - startY;\n      var dx = deltaX / this.getDomainScale(lastDomain, scale, \"x\");\n      var dy = deltaY / this.getDomainScale(lastDomain, scale, \"y\");\n      var currentDomain = {\n        x: zoomDimension === \"y\" ? originalDomain.x : this.pan(lastDomain.x, originalDomain.x, dx),\n        y: zoomDimension === \"x\" ? originalDomain.y : this.pan(lastDomain.y, originalDomain.y, dy)\n      };\n      var resumeAnimation = this.handleAnimation(ctx);\n      var zoomActive = !this.checkDomainEquality(originalDomain, lastDomain);\n      var mutatedProps = {\n        parentControlledProps: [\"domain\"],\n        startX: x,\n        startY: y,\n        parentSVG: parentSVG,\n        currentDomain: currentDomain,\n        originalDomain: originalDomain,\n        cachedZoomDomain: zoomDomain,\n        zoomActive: zoomActive\n      };\n      if (_isFunction(onZoomDomainChange)) {\n        onZoomDomainChange(currentDomain, _defaults({}, mutatedProps, targetProps));\n      }\n      return [{\n        target: \"parent\",\n        callback: resumeAnimation,\n        mutation: function mutation() {\n          return mutatedProps;\n        }\n      }];\n    }\n    return undefined;\n  },\n  // eslint-disable-next-line max-params\n  onWheel: function onWheel(evt, targetProps, eventKey, ctx) {\n    if (!targetProps.allowZoom) {\n      return undefined;\n    }\n    var onZoomDomainChange = targetProps.onZoomDomainChange,\n      zoomDimension = targetProps.zoomDimension,\n      zoomDomain = targetProps.zoomDomain;\n    var originalDomain = this.getDomain(targetProps);\n    var lastDomain = this.getLastDomain(targetProps, originalDomain);\n    var x = lastDomain.x,\n      y = lastDomain.y;\n    var currentDomain = {\n      x: zoomDimension === \"y\" ? lastDomain.x : this.scale(x, evt, targetProps, \"x\"),\n      y: zoomDimension === \"x\" ? lastDomain.y : this.scale(y, evt, targetProps, \"y\")\n    };\n    var resumeAnimation = this.handleAnimation(ctx);\n    var zoomActive = !this.zoommingOut(evt) ||\n    // if zoomming in or\n    //   if zoomActive is already set AND user hasn't zoommed out all the way\n    targetProps.zoomActive && !this.checkDomainEquality(originalDomain, lastDomain);\n    var mutatedProps = {\n      currentDomain: currentDomain,\n      originalDomain: originalDomain,\n      cachedZoomDomain: zoomDomain,\n      parentControlledProps: [\"domain\"],\n      panning: false,\n      zoomActive: zoomActive\n    };\n    if (_isFunction(onZoomDomainChange)) {\n      onZoomDomainChange(currentDomain, _defaults({}, mutatedProps, targetProps));\n    }\n    return [{\n      target: \"parent\",\n      callback: resumeAnimation,\n      mutation: function mutation() {\n        return mutatedProps;\n      }\n    }];\n  }\n};\nexport { RawZoomHelpers }; // allow victory-native to extend these helpers\n\nexport default {\n  checkDomainEquality: RawZoomHelpers.checkDomainEquality.bind(RawZoomHelpers),\n  onMouseDown: RawZoomHelpers.onMouseDown.bind(RawZoomHelpers),\n  onMouseUp: RawZoomHelpers.onMouseUp.bind(RawZoomHelpers),\n  onMouseLeave: RawZoomHelpers.onMouseLeave.bind(RawZoomHelpers),\n  onMouseMove: _throttle(RawZoomHelpers.onMouseMove.bind(RawZoomHelpers), 16,\n  // eslint-disable-line no-magic-numbers\n  {\n    leading: true,\n    trailing: false\n  }),\n  onWheel: _throttle(RawZoomHelpers.onWheel.bind(RawZoomHelpers), 16,\n  // eslint-disable-line no-magic-numbers\n  {\n    leading: true,\n    trailing: false\n  })\n};","map":null,"metadata":{},"sourceType":"module"}
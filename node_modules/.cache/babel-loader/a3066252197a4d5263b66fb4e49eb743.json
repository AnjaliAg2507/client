{"ast":null,"code":"import _without from \"lodash/without\";\nimport _includes from \"lodash/includes\";\nimport _values from \"lodash/values\";\nimport _orderBy from \"lodash/orderBy\";\nimport _range from \"lodash/range\";\nimport _uniq from \"lodash/uniq\";\nimport _invert from \"lodash/invert\";\nimport _isObject from \"lodash/isObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport _assign from \"lodash/assign\";\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport React from \"react\";\nimport * as Collection from \"./collection\";\nimport * as Domain from \"./domain\";\nimport * as Helpers from \"./helpers\";\n\n/**\n * Returns the axis (x or y) of a particular axis component\n * @param {Object} props: the props object.\n * @param {Boolean} horizontal: true for horizontal charts\n * @returns {String} the dimension appropriate for the axis given its props\n */\nexport function getAxis(props) {\n  var dependentAxis = props.dependentAxis;\n  return dependentAxis ? \"y\" : \"x\";\n}\n/**\n * Returns all axis components that pass a given predicate\n * @param {Array} childComponents: an array of children\n * @param {Function} predicate: a predicate function that will be called with each\n * @returns {Array} all axis components that pass the given predicate or []\n */\n\nexport function findAxisComponents(childComponents, predicate) {\n  predicate = predicate || _identity;\n  var findAxes = function findAxes(children) {\n    return children.reduce(function (memo, child) {\n      if (child.type && child.type.role === \"axis\" && predicate(child)) {\n        return memo.concat(child);\n      } else if (child.props && child.props.children) {\n        return memo.concat(findAxes(React.Children.toArray(child.props.children)));\n      }\n      return memo;\n    }, []);\n  };\n  return findAxes(childComponents);\n}\n/**\n * Returns a single axis component of the desired axis type (x or y)\n * @param {Array} childComponents: an array of children\n * @param {String} axis: desired axis either \"x\" or \"y\".\n * @returns {ReactComponent} an axis component of the desired axis or undefined\n */\n\nexport function getAxisComponent(childComponents, axis) {\n  var matchesAxis = function matchesAxis(component) {\n    var type = component.type.getAxis(component.props);\n    return type === axis;\n  };\n  return findAxisComponents(childComponents, matchesAxis)[0];\n}\n/**\n * Returns all axis components of the desired axis type (x or y) along with any\n * parent components excluding VictoryChart\n * @param {Array} childComponents: an optional array of children.\n * @param {String} type: desired axis either \"dependent\" or \"independent\".\n * @returns {ReactComponent} an axis component of the desired type or undefined\n */\n\nexport function getAxisComponentsWithParent(childComponents, type) {\n  var matchesType = function matchesType(child) {\n    return type === \"dependent\" ? child.props.dependentAxis : !child.props.dependentAxis;\n  };\n  var findComponents = function findComponents(children) {\n    return children.reduce(function (memo, child) {\n      if (child.type && child.type.role === \"axis\" && matchesType(child)) {\n        return memo.concat(child);\n      } else if (child.props && child.props.children) {\n        var childAxis = findComponents(React.Children.toArray(child.props.children));\n        return childAxis.length > 0 ? memo.concat(child) : memo;\n      }\n      return memo;\n    }, []);\n  };\n  return findComponents(childComponents);\n}\nexport function getOrigin(domain) {\n  var getSingleOrigin = function getSingleOrigin(d) {\n    var domainMin = Math.min.apply(Math, _toConsumableArray(d));\n    var domainMax = Math.max.apply(Math, _toConsumableArray(d));\n    return domainMax < 0 ? domainMax : Math.max(0, domainMin);\n  };\n  return {\n    x: Collection.containsDates(domain.x) ? new Date(Math.min.apply(Math, _toConsumableArray(domain.x))) : getSingleOrigin(domain.x),\n    y: Collection.containsDates(domain.y) ? new Date(Math.min.apply(Math, _toConsumableArray(domain.y))) : getSingleOrigin(domain.y)\n  };\n}\nexport function getOriginSign(origin, domain) {\n  var getSign = function getSign() {\n    return origin <= 0 && Math.max.apply(Math, _toConsumableArray(domain)) <= 0 ? \"negative\" : \"positive\";\n  };\n  return Collection.containsDates(domain) ? \"positive\" : getSign();\n}\n/**\n * @param {Object} props: axis component props\n * @returns {Boolean} true when the axis is vertical\n */\n\nexport function isVertical(props) {\n  var orientation = props.orientation || (props.dependentAxis ? \"left\" : \"bottom\");\n  var vertical = {\n    top: false,\n    bottom: false,\n    left: true,\n    right: true\n  };\n  return vertical[orientation];\n}\n/**\n * @param {Object} props: axis component props\n * @returns {Boolean} true when tickValues contain strings\n */\n\nexport function stringTicks(props) {\n  return props.tickValues !== undefined && Collection.containsStrings(props.tickValues);\n}\nfunction getDefaultTickFormat(props) {\n  var tickValues = props.tickValues;\n  var axis = getAxis(props);\n  var stringMap = props.stringMap && props.stringMap[axis];\n  var fallbackFormat = tickValues && !Collection.containsDates(tickValues) ? function (x) {\n    return x;\n  } : undefined;\n  if (!stringMap) {\n    return stringTicks(props) ? function (x, index) {\n      return tickValues[index];\n    } : fallbackFormat;\n  }\n  var invertedStringMap = stringMap && _invert(stringMap);\n  var tickValueArray = _orderBy(_values(stringMap), function (n) {\n    return n;\n  });\n  var dataNames = tickValueArray.map(function (tick) {\n    return invertedStringMap[tick];\n  }); // string ticks should have one tick of padding at the beginning\n\n  var dataTicks = [\"\"].concat(_toConsumableArray(dataNames), [\"\"]);\n  return function (x) {\n    return dataTicks[x];\n  };\n}\nfunction getStringTicks(props) {\n  var axis = getAxis(props);\n  var stringMap = props.stringMap && props.stringMap[axis];\n  var categories = Array.isArray(props.categories) ? props.categories : props.categories && props.categories[axis];\n  var ticksFromCategories = categories && Collection.containsOnlyStrings(categories) ? categories.map(function (tick) {\n    return stringMap[tick];\n  }) : undefined;\n  var ticksFromStringMap = stringMap && _values(stringMap);\n  return ticksFromCategories && ticksFromCategories.length !== 0 ? ticksFromCategories : ticksFromStringMap;\n}\nfunction getTickArray(props) {\n  var tickValues = props.tickValues,\n    tickFormat = props.tickFormat;\n  var axis = getAxis(props);\n  var stringMap = props.stringMap && props.stringMap[axis];\n  var getTicksFromFormat = function getTicksFromFormat() {\n    if (!tickFormat || !Array.isArray(tickFormat)) {\n      return undefined;\n    }\n    return Collection.containsStrings(tickFormat) ? tickFormat.map(function (t, i) {\n      return i;\n    }) : tickFormat;\n  };\n  var ticks = tickValues;\n  if (stringMap) {\n    ticks = getStringTicks(props);\n  }\n  if (tickValues && Collection.containsStrings(tickValues)) {\n    ticks = stringMap ? tickValues.map(function (tick) {\n      return stringMap[tick];\n    }) : _range(1, tickValues.length + 1);\n  }\n  var tickArray = ticks ? _uniq(ticks) : getTicksFromFormat();\n  var buildTickArray = function buildTickArray(arr) {\n    var newTickArray = [];\n    var domain = props.domain && props.domain[axis] || props.domain;\n    if (arr) {\n      arr.forEach(function (t, index) {\n        if (Array.isArray(domain)) {\n          if (t >= Collection.getMinValue(domain) && t <= Collection.getMaxValue(domain)) {\n            newTickArray.push({\n              value: t,\n              index: index\n            });\n          }\n        } else {\n          newTickArray.push({\n            value: t,\n            index: index\n          });\n        }\n      });\n      return newTickArray;\n    }\n    return undefined;\n  };\n  return Array.isArray(tickArray) && tickArray.length ? buildTickArray(tickArray) : undefined;\n}\nexport function getTickFormat(props, scale) {\n  var tickFormat = props.tickFormat;\n  var axis = getAxis(props);\n  var stringMap = props.stringMap && props.stringMap[axis];\n  if (!tickFormat) {\n    var defaultTickFormat = getDefaultTickFormat(props); // If there is no user-provided tick format, we use d3's tickFormat function\n    // by default. This changed the default formatting for some scale types when\n    // we upgraded to d3-scale@4..\n\n    var scaleTickFormat = scale.tickFormat && _isFunction(scale.tickFormat) ? scale.tickFormat() : function (x) {\n      return x;\n    };\n    return defaultTickFormat || scaleTickFormat;\n  } else if (tickFormat && Array.isArray(tickFormat)) {\n    var tickArray = getTickArray(props);\n    var tickArrayIndices = tickArray === null || tickArray === void 0 ? void 0 : tickArray.map(function (v) {\n      return v.index;\n    });\n    var filteredTickFormat = tickFormat.filter(function (t, index) {\n      return tickArrayIndices === null || tickArrayIndices === void 0 ? void 0 : tickArrayIndices.includes(index);\n    });\n    return function (x, index) {\n      return filteredTickFormat[index];\n    };\n  } else if (tickFormat && _isFunction(tickFormat)) {\n    var applyStringTicks = function applyStringTicks(tick, index, ticks) {\n      var invertedStringMap = _invert(stringMap);\n      var stringTickArray = ticks.map(function (t) {\n        return invertedStringMap[t];\n      });\n      return props.tickFormat(invertedStringMap[tick], index, stringTickArray);\n    };\n    return stringMap ? applyStringTicks : tickFormat;\n  }\n  return function (x) {\n    return x;\n  };\n}\nfunction downsampleTicks(ticks, tickCount) {\n  if (!tickCount || !Array.isArray(ticks) || ticks.length <= tickCount) {\n    return ticks;\n  }\n  var k = Math.floor(ticks.length / tickCount);\n  return ticks.filter(function (d, i) {\n    return i % k === 0;\n  });\n}\nexport function getTicks(props, scale) {\n  var filterZero = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var tickCount = props.tickCount;\n  var tickArray = getTickArray(props);\n  var tickValues = tickArray ? tickArray.map(function (v) {\n    return v.value;\n  }) : undefined;\n  if (tickValues) {\n    return downsampleTicks(tickValues, tickCount);\n  } else if (scale.ticks && _isFunction(scale.ticks)) {\n    // eslint-disable-next-line no-magic-numbers\n    var defaultTickCount = tickCount || 5;\n    var scaleTicks = scale.ticks(defaultTickCount);\n    var scaledTickArray = Array.isArray(scaleTicks) && scaleTicks.length ? scaleTicks : scale.domain();\n    var ticks = downsampleTicks(scaledTickArray, tickCount);\n    if (filterZero) {\n      var filteredTicks = _includes(ticks, 0) ? _without(ticks, 0) : ticks;\n      return filteredTicks.length ? filteredTicks : ticks;\n    }\n    return ticks;\n  }\n  return scale.domain();\n}\n/**\n * Returns a domain based tickValues\n * @param {Object} props: the props object\n * @param {String} axis: either x or y\n * @returns {Array} returns a domain from tickValues\n */\n// eslint-disable-next-line max-statements\n\nfunction getDomainFromData(props, axis) {\n  var polar = props.polar,\n    _props$startAngle = props.startAngle,\n    startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n    _props$endAngle = props.endAngle,\n    endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n  var tickArray = getTickArray(props);\n  var tickValues = tickArray ? tickArray.map(function (v) {\n    return v.value;\n  }) : undefined;\n  if (!Array.isArray(tickValues)) {\n    return undefined;\n  }\n  var minDomain = Domain.getMinFromProps(props, axis);\n  var maxDomain = Domain.getMaxFromProps(props, axis);\n  var tickStrings = stringTicks(props);\n  var ticks = tickValues.map(function (value) {\n    return Number(value);\n  });\n  var defaultMin = tickStrings ? 1 : Collection.getMinValue(ticks);\n  var defaultMax = tickStrings ? tickValues.length : Collection.getMaxValue(ticks);\n  var min = minDomain !== undefined ? minDomain : defaultMin;\n  var max = maxDomain !== undefined ? maxDomain : defaultMax;\n  var initialDomain = Domain.getDomainFromMinMax(min, max);\n  var domain = polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? Domain.getSymmetricDomain(initialDomain, ticks) : initialDomain;\n  if (isVertical(props) && !polar) {\n    domain.reverse();\n  }\n  return domain;\n} // exposed for use by VictoryChart\n\nexport function getDomain(props, axis) {\n  var inherentAxis = getAxis(props);\n  if (axis && axis !== inherentAxis) {\n    return undefined;\n  }\n  return Domain.createDomainFunction(getDomainFromData)(props, inherentAxis);\n}\nexport function getAxisValue(props, axis) {\n  if (!props.axisValue) {\n    return undefined;\n  }\n  var scaleAxis = axis === \"x\" ? \"y\" : \"x\";\n  var scale = _isObject(props.scale) && _isFunction(props.scale[scaleAxis]) ? props.scale[scaleAxis] : undefined;\n  if (!scale) {\n    return undefined;\n  }\n  var stringMapAxis = axis === \"x\" ? \"y\" : \"x\";\n  var stringMap = _isObject(props.stringMap) && props.stringMap[stringMapAxis];\n  var axisValue = stringMap && typeof props.axisValue === \"string\" ? stringMap[props.axisValue] : props.axisValue;\n  return scale(axisValue);\n}\nexport function modifyProps(props, fallbackProps) {\n  if (!_isObject(props.theme)) {\n    return Helpers.modifyProps(props, fallbackProps, \"axis\");\n  }\n  var role = \"axis\";\n  if (props.dependentAxis && props.theme.dependentAxis) {\n    role = \"dependentAxis\";\n  } else if (!props.dependentAxis && props.theme.independentAxis) {\n    role = \"independentAxis\";\n  }\n  if (role === \"axis\") {\n    return Helpers.modifyProps(props, fallbackProps, \"axis\");\n  }\n  var axisTheme = _defaults({}, props.theme[role], props.theme.axis);\n  var theme = _assign({}, props.theme, {\n    axis: axisTheme\n  });\n  return Helpers.modifyProps(_assign({}, props, {\n    theme: theme\n  }), fallbackProps, \"axis\");\n}","map":null,"metadata":{},"sourceType":"module"}
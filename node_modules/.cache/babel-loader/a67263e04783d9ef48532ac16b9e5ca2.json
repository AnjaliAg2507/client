{"ast":null,"code":"import _assign from \"lodash/assign\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport { getBarPath, getBarWidth, getCornerRadius, getPolarBarPath, getStyle } from \"victory-bar\";\nimport { useCanvasContext } from \"./hooks/use-canvas-context\";\nimport { CommonProps } from \"victory-core\";\nvar evaluateProps = function evaluateProps(props) {\n  /**\n   * Potential evaluated props of following must be evaluated in this order:\n   * 1) `style`\n   * 2) `barWidth`\n   * 3) `cornerRadius`\n   */\n  var style = getStyle(props.style, props);\n  var barWidth = getBarWidth(props.barWidth, _assign({}, props, {\n    style: style\n  }));\n  var cornerRadius = getCornerRadius(props.cornerRadius, _assign({}, props, {\n    style: style,\n    barWidth: barWidth\n  }));\n  return _assign({}, props, {\n    style: style,\n    barWidth: barWidth,\n    cornerRadius: cornerRadius\n  });\n};\nexport var usePreviousValue = function usePreviousValue(value) {\n  var ref = React.useRef();\n  React.useEffect(function () {\n    ref.current = value;\n  });\n  return ref.current;\n};\nvar CanvasBar = function CanvasBar(initialProps) {\n  var _useCanvasContext = useCanvasContext(),\n    canvasRef = _useCanvasContext.canvasRef;\n  var props = evaluateProps(initialProps);\n  var polar = props.polar,\n    style = props.style,\n    barWidth = props.barWidth,\n    cornerRadius = props.cornerRadius,\n    origin = props.origin;\n  var path2d = React.useMemo(function () {\n    var p = polar ? getPolarBarPath(props, cornerRadius) : getBarPath(props, barWidth, cornerRadius);\n    return new Path2D(p);\n  }, [polar, barWidth, cornerRadius, props]);\n  var previousPath = usePreviousValue(path2d);\n  var draw = React.useCallback(function (ctx, path) {\n    ctx.fillStyle = style.fill;\n    ctx.strokeStyle = style.stroke;\n    ctx.globalAlpha = style.fillOpacity;\n    ctx.lineWidth = style.strokeWidth;\n    if (polar) {\n      ctx.translate(origin.x, origin.y);\n    }\n    ctx.fill(path);\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  }, [style, origin, polar]); // This will clear the previous bar without clearing the entire canvas\n\n  var clearPreviousPath = React.useCallback(function (ctx) {\n    if (previousPath) {\n      ctx.save(); // This ensures that the entire shape is erased\n\n      ctx.lineWidth = style.strokeWidth + 2;\n      ctx.globalCompositeOperation = \"destination-out\";\n      draw(ctx, previousPath);\n      ctx.stroke(previousPath);\n      ctx.restore();\n    }\n  }, [draw, previousPath, style]);\n  React.useEffect(function () {\n    var ctx = canvasRef.current.getContext(\"2d\");\n    clearPreviousPath(ctx);\n    draw(ctx, path2d);\n  }, [canvasRef, draw, polar, barWidth, cornerRadius, props, path2d, clearPreviousPath]);\n  return null;\n};\nCanvasBar.propTypes = _objectSpread(_objectSpread({}, CommonProps.primitiveProps), {}, {\n  alignment: PropTypes.oneOf([\"start\", \"middle\", \"end\"]),\n  barRatio: PropTypes.number,\n  barWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  cornerRadius: PropTypes.oneOfType([PropTypes.number, PropTypes.func, PropTypes.shape({\n    top: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    topLeft: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    topRight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    bottom: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    bottomLeft: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    bottomRight: PropTypes.oneOfType([PropTypes.number, PropTypes.func])\n  })]),\n  datum: PropTypes.object,\n  getPath: PropTypes.func,\n  horizontal: PropTypes.bool,\n  width: PropTypes.number,\n  x: PropTypes.number,\n  y: PropTypes.number,\n  y0: PropTypes.number\n});\nexport default CanvasBar;","map":null,"metadata":{},"sourceType":"module"}